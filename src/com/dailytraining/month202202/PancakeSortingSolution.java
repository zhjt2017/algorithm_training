package com.dailytraining.month202202;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;

/**
 * 算法训练(2022-02-19) 煎饼排序
 * - https://leetcode-cn.com/problems/pancake-sorting/ (969题)
 * <p>
 * - 给你一个整数数组 arr ，请使用 煎饼翻转 完成对数组的排序。
 * - 一次煎饼翻转的执行过程如下：
 * - 选择一个整数 k ，1 <= k <= arr.length
 * - 反转子数组 arr[0...k-1]（下标从 0 开始）
 * - 例如，arr = [3,2,1,4] ，选择 k = 3 进行一次煎饼翻转，反转子数组 [3,2,1] ，得到 arr = [1,2,3,4] 。
 * <p>
 * 以数组形式返回能使 arr 有序的煎饼翻转操作所对应的 k 值序列。
 * 任何将数组排序且翻转次数在 10 * arr.length 范围内的有效答案都将被判断为正确。
 * <p>
 * - 输入：[3,2,4,1]
 * 输出：[4,2,4,3]
 * 解释：
 * 我们执行 4 次煎饼翻转，k 值分别为 4，2，4，和 3。
 * 初始状态 arr = [3, 2, 4, 1]
 * 第一次翻转后（k = 4）：arr = [1, 4, 2, 3]
 * 第二次翻转后（k = 2）：arr = [4, 1, 2, 3]
 * 第三次翻转后（k = 4）：arr = [3, 2, 1, 4]
 * 第四次翻转后（k = 3）：arr = [1, 2, 3, 4]，此时已完成排序。
 * <p>
 * - 输入：[1,2,3]
 * 输出：[]
 * 解释：
 * 输入已经排序，因此不需要翻转任何内容。
 * 请注意，其他可能的答案，如 [3，3] ，也将被判断为正确。
 * <p>
 * 1 <= arr.length <= 100
 * 1 <= arr[i] <= arr.length
 * arr 中的所有整数互不相同（即，arr 是从 1 到 arr.length 整数的一个排列）
 * <p>
 * -----------------------------------------------------------------------------------------------------------------------------------
 * 煎饼排序问题的渊源：
 * 煎饼排序是数量问题的口语术语，当刮刀可以插入堆叠中的任何点并用于翻转其上方的所有薄饼时，按照尺寸的顺序对无序堆叠的薄煎饼进行分类。
 * 煎饼数是给定数量的煎饼所需的最小翻转数。 在这种形式下，问题首先由美国几何学家Jacob E. Goodman讨论过。
 * 它是排序问题的变体，其中唯一允许的操作是反转序列的某些前缀的元素。
 * 与传统的排序算法不同，传统的排序算法试图以尽可能少的比较进行排序，目标是尽可能少地对序列进行排序。
 * 该问题的一个变体涉及烧焦的煎饼，其中每个煎饼具有烧焦的一面，并且所有的煎饼必须另外在底部烧焦的一面。
 * <p>
 * 字符串上的煎饼问题：
 * 上面的讨论假定每个煎饼是唯一的，即，执行前缀反转的序列是置换。
 * 然而，“字符串”是符号可以重复的序列，并且这种重复可以减少排序所需的前缀反转的数量。
 * Chitturi和Sudborough（2010年）和Hurkens等人。
 * （2007）独立地表明，将具有最小前缀反转次数的兼容字符串转换为另一种字符串的复杂性是NP完全的。
 * 他们也给了同样的限制 [1]  。 Hurkens等人。给出了一个精确的算法来排序二进制和三进制字符串。
 * Chitturi（2011）证明了将兼容的带符号字符串转换为另一个具有最小签名前缀反转次数的复杂性 - 字符串上烧焦的煎饼问题-是NP完全的。
 * - NP完全问题(NP-C问题)，是世界七大数学难题之一。
 * - NP的英文全称是Non-deterministic Polynomial的问题，即多项式复杂程度的非确定性问题。
 * - 简单的写法是 NP=P？，问题就在这个问号上，到底是NP等于P，还是NP不等于P。
 * <p>
 * 煎饼分拣问题首先由雅各布·E·古德曼（Jacob E. Goodman）提出，用笔名“哈利·加勒特”（Harry Dweighter）（匆忙的服务员）撰写。
 * 虽然经常被视为一种教育设备，但煎饼分类也出现在并行处理器网络的应用中，它可以在处理器之间提供有效的路由算法。
 * <p>
 * 这个问题值得注意的是微软创始人比尔盖茨（作为威廉盖茨）唯一着名的数学论文题目，题为“按前缀逆转排序的界限”。
 * 它出版于1979年，它描述了一种有效的煎饼分选算法。
 * 此外，由Futurama联合创始人David X. Cohen（作为David S. Cohen）发表的最着名的论文涉及烧焦的煎饼问题。
 * 他们的合作者分别是Christos Papadimitriou（当时在哈佛大学，现在在哥伦比亚大学）和Manuel Blum（当时在伯克利，现在在卡内基梅隆大学）。
 * <p>
 * 最近还研究了通过逆转进行符号排序和通过逆转进行排序的相关问题。
 * 虽然已经通过反转找到了有效的精确算法用于带符号的排序，已经证明通过反转排序的问题甚至难以逼近某个常数因子，并且也被证明在多项式时间内是近似的。在近似因子1.375内。
 * <p>
 * 多项式时间 我们可以将时间复杂度分为两类；
 * 第一类我们称为多项式级的复杂度，其规模 n 出现在底数的位置
 * 第二类我们称为非多项式级的复杂度
 * 我们将第一类时间复杂度称为多项式时间。
 * P 问题 如果一个问题可以找到一个能在多项式的时间里解决它的算法，那么这个问题就属于 P 问题。
 * NP 问题 NP 问题有两种定义。第一种定义：如果一个问题可以在多项式的时间内验证一个解的问题，那么这个问题就属于 NP 问题。
 * 第二种定义：如果一个问题可以在多项式的时间内猜出一个解，那么这个问题就属于 NP 问题。
 * 约化 一个问题 A 可以约化为问题 B 的含义是，可以用问题 B 的解法解决问题 A。
 * 一般来说，B 的时间复杂度高于或等于 A 的时间复杂度。
 * 另外，约化具有传递性，如果问题 A 可约化为问题 B，问题 B 可约化为问题 C，则问题 A 一定可约化为问题 C。
 * NPC 问题(NP 完全问题) NPC 问题定义为同时满足如下两个条件的问题。
 * 首先，它必须是一个 NP 问题；然后，所有的 NP 问题都可以约化到它。
 * 在现阶段，我们可以直观地理解，NPC 问题目前没有多项式的有效算法，只能用指数级甚至阶乘级复杂度的搜索。
 * NP-Hard 问题 NP-Hard 问题不一定是一个 NP 问题，但是所有的 NP 问题都可以约化到它
 * <p>
 * - 逻辑电路问题是NPC类问题的“鼻祖” (给定一个逻辑电路，问是否存在一种输入使输出为True)
 * - 有输出无论如何都不可能为True的逻辑电路吗？有
 * - 逻辑电路问题属于NPC问题。这是有严格证明的。
 * - 它显然属于NP问题，并且可以直接证明所有的NP问题都可以约化到它（不要以为NP问题有无穷多个将给证明造成不可逾越的困难）。
 * - 证明过程相当复杂，其大概意思是说任意一个NP问题的输入和输出都可以转换成逻辑电路的输入和输出（想想计算机内部也不过是一些 0和1的运算）。
 * - 因此对于一个NP问题来说，问题转化为了求出满足结果为True的一个输入（即一个可行解）。
 *
 * @author bruce.zhu@GeekTrainingCamp
 * @since 2022-02-19 11:45:58
 */
public class PancakeSortingSolution {
    public static void main(String[] args) {
        final PancakeSortingSolution solution = new PancakeSortingSolution();

        int[] arr = new int[]{3, 2, 4, 1};
        System.out.println("Input arr : " + Arrays.toString(arr));
        System.out.println("Output pancake sorting path : " + solution.pancakeSort(arr));
    }

    /**
     * 总共执行至多 n - 1 次查找最大值，至多 2 × (n − 1) 次反转数组
     * 时间复杂度 O(N^2)
     * 空间复杂度 O(1)
     *
     * @param arr
     * @return
     */
    List<Integer> pancakeSort(final int[] arr) {
        final List<Integer> ans = new ArrayList<>(arr.length << 1);
        for (int n = arr.length; n > 1; n--) {
            // 找到最大值所在位置
            int index = 0;
            for (int i = 1; i < n; i++) {
                if (arr[i] >= arr[index]) {
                    index = i;
                }
            }
            // 如果最后一个位置是最大值，则最大值不用翻转
            if (index == n - 1) {
                continue;
            }
            // 第1次翻转，将最大值翻转到头部，第二次翻转，将最大值又挪到尾部 (如果已经在头部，省去该次翻转)
            if (index != 0) {
                reverse(arr, index);
                ans.add(index + 1);
            }
            reverse(arr, n - 1);
            ans.add(n);
        }
        return ans;
    }

    /**
     * 从0到end反转数组
     *
     * @param arr
     * @param end
     */
    private void reverse(int[] arr, int end) {
        for (int i = 0, j = end; i < j; i++, j--) {
            int temp = arr[i];
            arr[i] = arr[j];
            arr[j] = temp;
        }
    }
}
